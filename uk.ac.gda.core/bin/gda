#! /usr/bin/env python

import sys
import os
import time
import subprocess
import signal
import platform
import glob
from optparse import OptionParser, OptionGroup
import operator
import re
from xml.dom import minidom
from types import MethodType

DEFAULT_SERVER_DEBUG_PORT = 8000
DEFAULT_CLIENT_DEBUG_PORT = 8001

OLD = 'old'
NEW = 'new'
STANDARD = 'standard'
#===========================================================================================================================#

import logging  # @UnusedImport (suppress an incorrect warning raised by PyDev)
import logging.handlers  # @UnusedImport (suppress an incorrect warning raised by PyDev)

class LoggingFilter(logging.Filter):
	""" Filter out log messages with a log level of ERROR and above
		Used so that ERROR+ messages are not written to stdout, just stderr
	"""

	def filter(self, record):  # @ReservedAssignment
		return record.levelno < logging.ERROR

def define_loggers(log_level=logging.INFO):
	""" Set up logging so that ERROR and above goes to stderr, and everything else goes to stdout.
		You can define additional handlers here if you want.
		By default we log INFO and above, use command line option --verbose for DEBUG and above, and --trace for TRACE and above (very verbose)
	"""

	logging.addLevelName(1, 'TRACE')  # for more detail than DEBUG, selected by command line option --trace
	logger = logging.getLogger('GDA_start')
	logger.trace = MethodType(lambda logger_self, msg: logger_self.log(1, msg), logger, logger.__class__)

	logger.setLevel(log_level)
	formatter = logging.Formatter("%(asctime)s %(levelname)-5s - %(message)s", "%Y-%m-%d %H:%M:%S")

	console_handler_stdout = logging.StreamHandler(sys.stdout)
	console_handler_stdout.setFormatter(formatter)
	console_handler_stdout.addFilter(LoggingFilter())  # the filter means that this handler ignores messages of log level ERROR and above
	logger.addHandler(console_handler_stdout)

	console_handler_stderr = logging.StreamHandler(sys.stderr)
	console_handler_stderr.setFormatter(formatter)
	console_handler_stderr.setLevel(logging.ERROR)  # the setlevel means that this handler ignores messages below log level ERROR
	logger.addHandler(console_handler_stderr)

#===========================================================================================================================#

class PluginData(object):
	""" Class to return information about a plugin
		@param plugin_path: path to the plugin directory
		@type lib_subdir: name of the lib/ sub-directory for this machine
		Can be re-initialised with a new plugin
	"""
	def __init__(self, lib_subdir):
		self.logger = logging.getLogger('GDA_start')  # get the logger instance
		if not lib_subdir:
			self.logger.critical('lib_subdir must be specified')
		else:
			self.lib_subdir = lib_subdir

	def setup(self, plugin_path):
		plugin_path = os.path.abspath(plugin_path)
		if not os.path.isdir(plugin_path):
			self.logger.critical('Plugin directory "%s" does not exist' % (plugin_path,))
		self.plugin_path = plugin_path
		self.lib_dir = os.path.join(self.plugin_path, 'lib', self.lib_subdir)
		if not (os.path.isdir(self.lib_dir) and os.listdir(self.lib_dir)):
			self.lib_dir = None
		self.manifest_lines = None

	def _manifestLines(self):
		# read the plugin MANIFEST.MF for later parsing
		if self.manifest_lines:
			return self.manifest_lines
		self.manifest = os.path.join(self.plugin_path, 'META-INF', 'MANIFEST.MF')
		if not os.path.isfile(self.manifest):
			self.logger.error('Manifest file "%s" does not exist' % (self.manifest,))
			self.manifest_lines = []
			return
		with open(self.manifest, 'r') as manifest_file:
			self.manifest_lines = manifest_file.readlines()
		if not self.manifest_lines:
			self.logger.error('Manifest file "%s" is empty' % (self.manifest,))
		return self.manifest_lines

	def _getManifestSection(self, section_prefix):
		items = []
		addToItems = False
		for line in self._manifestLines():
			line = line.strip()
			if line.startswith(section_prefix):
				line = line.split(section_prefix, 1)[1]
				addToItems = True;
			if addToItems:
				items.append(line.split(",", 1)[0].strip())
				if not line.endswith(','):
					break
		return items

	def requireBundleSection(self):
		""" Returns a list of bundles names in the Require-Bundle section of the manifest, which looks like:
				Require-Bundle: org.eclipse.ui,
				 org.eclipse.core.runtime,
				 uk.ac.gda.libs;bundle-version="1.0.0",
				 uk.ac.gda.epics.client;bundle-version="1.0.0",
				 uk.ac.gda.epics,
				 uk.ac.diamond.scisoft.analysis.rcp;bundle-version="1.0.0"
 		"""
		items = [line.split(";", 1)[0].strip() for line in self._getManifestSection("Require-Bundle:")]
		self.logger.debug('Manifest Require-Bundle in "%s" was: %s' % (self.manifest, items))
		return items

	def bundleClassPathSection(self):
		""" Returns a list of absolute paths for entries in the Bundle-ClassPath section of the manifest, which looks like:
				Bundle-ClassPath: .,
				 jars/gda-corba.jar,
				 scripts/
			The "." entry is ignored
			An error is logged if an entry does not exist in the filesystem
 		"""
		items = []
		for entry in self._getManifestSection("Bundle-ClassPath:"):
			if entry == '.':
				continue
			path = os.path.join(self.plugin_path, entry)
			if os.path.exists(path):
				if path not in items:
					items.append(path)
			else:
				self.logger.warn('Manifest Bundle-ClassPath in "%s" references non-existent jar "%s"' % (self.plugin_path, path))
		self.logger.debug('Manifest Bundle-ClassPath in "%s" was: %s' % (self.plugin_path, items))
		return items

#===========================================================================================================================#

class GdaOS:
	"""
	class to mock the os module
	"""
	def __init__(self):
		self.logger = logging.getLogger('GDA_start')  # get the logger instance

	def putenv(self, env_name, env_value):
		# always put into environment even if in dry run mode as this
		# ensure other code that relies on it to work
		os.environ[env_name] = env_value
	
	def spawn_nowait(self, command, args, dry_run):
		"""Used to launch GDA processes without waiting; returns the PID of the
		new process"""
		self.logger.debug("Popen: %s" % (command,))
		self.logger.debug("       %s" % (args,))
		if not dry_run:
			return subprocess.Popen((command,) + args).pid
		else:
			self.logger.debug("subprocess.Popen(...) dry-run")
			return -1

	def popen_get_stdout(self, command, dry_run):
		"""Used to obtain various information from the operating system; returns
		a file-like object from which the output can be read"""
		self.logger.debug("Popen: %s" % (command,))
		if not dry_run:
			return subprocess.Popen(command, shell=True, stdout=subprocess.PIPE).stdout
		else:
			self.logger.debug("subprocess.Popen(... , shell=True, stdout=subprocess.PIPE) dry-run")
			return ""
	
	def runcmd_get_stdout(self, command, args, dry_run):
		"""Used to launch GDA processes and wait for their output; returns a
		file-like object from which the output can be read"""
		self.logger.debug("Popen: %s" % (command,))
		self.logger.debug("       %s" % (args,))
		if not dry_run:
			return subprocess.Popen((command,) + args, stdout=subprocess.PIPE).stdout
		else:
			self.logger.debug("subprocess.Popen(... , stdout=subprocess.PIPE) dry-run")
			return ""
	
	def run_in_foreground(self, command, args, dry_run):
		all_args = (command,) + args
		self.logger.debug("execv: %s" % (command,))
		self.logger.debug("       %s" % (args,))
		if not dry_run:
			os.execv(all_args[0], all_args)
		else:
			self.logger.debug("os.execv(...) dry-run")

def abspath(*bits):
	return os.path.abspath(os.path.join(*bits))

#===========================================================================================================================#

class GdaLauncher:

	usage_text = """gda [options] task

where task can be:
 nameserver    logserver     eventserver   objectserver
 servers
 logpanel
 namemanager
 client        rcpclient"""

	def __init__(self):
		self.logger = logging.getLogger('GDA_start')  # get the logger instance
		self.gdaos = GdaOS()


	def usage(self):
		print "usage: %s" % self.usage_text


	def define_parser(self):
		self.parser = OptionParser(usage=self.usage_text)
		self.parser.formatter.help_position = self.parser.formatter.max_help_position = 38  # improve look of help
		if not os.environ.has_key('COLUMNS'):  # typically this is not passed from the shell to the child process (Python)
			self.parser.formatter.width = 120  # so avoid the default of 80 and assume a wider terminal (improve look of help)

		self.parser.add_option("-n", "--dry-run", dest="dry_run", action="store_true", default=False, help="show what processes would be started and environment variables set")
		self.parser.add_option("-v", "--verbose", dest="verbose", action="store_true", default=False, help="increase verbosity")
		self.parser.add_option("--trace", dest="trace", action="store_true", default=False, help="increase verbosity again")

		group = OptionGroup(self.parser, "Actions")
		group.add_option("--version", dest="version", action="store_true", default=False, help="display GDA version")
		group.add_option("--restart", "--start", dest="start", action="store_true", help="(re)start the process; does --stop first (default)")
		group.add_option("--stop", dest="stop", action="store_true", help="stop the process")
		
		self.parser.add_option_group(group)

		group = OptionGroup(self.parser, "What to run")
		group.add_option("--profile", dest="profile", type="string", help="name of server/client profile to start, e.g. 'main' (default), 'camserver'", metavar="NAME")
		group.add_option("--mode", dest="gda_mode", type="string", help="mode in which to start the client/server(s), e.g. 'live' (default), 'dummy', 'simulation'", metavar="MODE")
		group.add_option("-x", "--osxml", dest="os_xml", type="string", help="override object server XML file", metavar="FILE")
		group.add_option("-t", "--testing", dest="testing", action="store_true", default=False, help="adds test classes to class path")
		group.add_option("-f", "--foreground", dest="foreground", action="store_true", default=False, help="run in foreground (only valid when starting a single process)")
		group.add_option("--headless", dest="headless", action="store_true", help="run the process with the headless flag")
		group.add_option("--lib_subdir", dest="lib_subdir", type="string", help="override lib sub directory, needed when platform.machine() result unrecognised")
		group.add_option("-s", "--smart", dest="smart", action="store_true", default=True, help="use smart dependencies to determine classpath")
		# DATAACQTEAM-154 support eclipse osgi application startup mode 
		group.add_option("--osgi", dest="osgi", action="store_true", help="run the servers using the osgi eclipse application - only use this with the 'gda servers' command")
		# END
		self.parser.add_option_group(group)

		group = OptionGroup(self.parser, "Configuration options")
		group.add_option("--config", dest="gda_config", type="string", help="override default gda.config", metavar="DIR")
		group.add_option("--logsdir", dest="gda_logdir", type="string", help="override default gda.logs.dir", metavar="DIR")
		group.add_option("--datadir", dest="gda_data", type="string", help="override default gda.data", metavar="DIR")
		group.add_option("--vardir", dest="gda_var", type="string", help="override default gda.var", metavar="DIR")
		group.add_option("--properties", dest="java_properties", type="string", help="override default gda.propertiesFile", metavar="FILE")
		group.add_option("--jacorb", dest="jacorb_config_dir", type="string", help="override default jacorb.config.dir", metavar="DIR")
		group.add_option("--jca", dest="jcalibrary_properties", type="string", help="override default gov.aps.jca.JCALibrary.properties", metavar="FILE")
		self.parser.add_option_group(group)

		group = OptionGroup(self.parser, "Client options")
		group.add_option("--rcp_image", dest="rcp_image", type="string", help="path to rcp image", metavar="FILE")
		group.add_option("--nosplash", dest="nosplash", action="store_true", default=False, help="don't show splash screen when starting client")
		self.parser.add_option_group(group)

		group = OptionGroup(self.parser, "Debugging")
		group.add_option("--nsport", dest="ns_port", type="int", default=6700, help="name server port (default 6700)", metavar="PORT")
		group.add_option("-d", "--debug", dest="debug", action="store_true", default=False, help="enable debugging; for 'servers', controls only the object server")
		group.add_option("-p", "--debugport", dest="debug_port", type="int", default=0, help="debug port (default 8000 for server components, 8001 for client); for 'servers', controls only the object server", metavar="PORT")
		group.add_option("--suspend", dest="debug_suspend", action="store_true", default=False, help="process suspends execution until attached to by a debugger")
		group.add_option("--profiler", dest="profiler", action="store_true", default=False, help="enable profiling. export PROFILER_DIR to specify profiler location")
		group.add_option("--profilerport", dest="profiler_port", type="int", default="8851", help="port for profiling (default 8851)", metavar="PORT")
		group.add_option("--threaddump", dest="threaddump", action="store_true", help="produce thread dumps for Java processes before they are stopped")
		self.parser.add_option_group(group)

		self.server_tasks = ["logserver", "nameserver", "eventserver", "objectserver", "servers"]
		self.client_tasks = ["logpanel", "namemanager", "client", "rcpclient", "userpermissions"]
		self.single_processes = ["logserver", "nameserver", "eventserver", "objectserver", "logpanel", "namemanager", "client"]


	def mainline(self, argv):

		self.get_commandlineArgs(argv)
		# this file is workspace_git/gda-core.git/uk.ac.gda.core/bin/gda
		self.gda_install_git_loc = os.path.realpath(abspath(os.path.realpath(os.path.dirname(__file__)), "..", "..", ".."))
		assert self.gda_install_git_loc.endswith("_git")
		self.gda_install_workspace_loc = self.gda_install_git_loc[:-4]
		assert os.path.isdir(self.gda_install_workspace_loc)
		
		# DATAACQTEAM-154 definitions associated with running the server as an eclipse osgi appilcation
		self.gda_workspace_parent = os.path.abspath(os.path.join(self.gda_install_git_loc, '..'))
		assert os.path.isdir(self.gda_workspace_parent)
		self.gda_install_springframework_jars_loc = abspath(self.gda_install_git_loc, "diamond-springframework.git", "uk.ac.diamond.org.springframework", "jars")
		assert os.path.isdir(self.gda_install_springframework_jars_loc)
		self.gda_product_present = False
		self.gda_install_product = abspath(self.gda_workspace_parent, "servers", "gda-server", "gda-server")
		self.gda_osgi_process_matcher = ('-Dosgi.gda.application=true',)
		if os.path.isfile(self.gda_install_product):
			self.gda_product_present = True
		elif self.options.osgi:
			self.logger.critical("Cannot start in osgi mode; gda-server application file is not present")
			sys.exit(1)
		# END

		self.logger.debug("gda_install_workspace_loc = " + self.gda_install_workspace_loc)
		self.logger.debug("gda_install_git_loc = " + str(self.gda_install_git_loc))
		# DATAACQTEAM-154
		self.logger.debug("gda_workspace_parent = " + self.gda_workspace_parent)
		self.logger.debug("gda_install_springframework_jars_loc = " + self.gda_install_springframework_jars_loc)
		self.logger.debug("gda_install_product = " + self.gda_install_product)
		# END
		self.determine_operating_environment()
		self.determine_gda_configuration()
		self.determine_gda_environment()
		self.determine_gda_data()
		self.build_class_path_and_library_path()
		self.log_gda_configuration_and_data()

		if self.options.version:
			return self.get_version()

		# default debug port depends on whether a server or client task is being started
		if self.options.debug_port == 0:
			if self.task in self.server_tasks:
				self.options.debug_port = DEFAULT_SERVER_DEBUG_PORT
			elif self.task in self.client_tasks:
				self.options.debug_port = DEFAULT_CLIENT_DEBUG_PORT

		# debug options used to start tasks (object server only for 'servers' task)
		debug_opts = {
			"debug": self.options.debug,
			"debug_port": self.options.debug_port,
			"debug_suspend": self.options.debug_suspend
		}

		will_start_objectserver = self.task in ("objectserver", "servers") and self.options.start
		if will_start_objectserver and self.layout != OLD:
			self.options.os_xml = abspath(self.options.gda_config, "servers", self.options.profile, self.options.gda_mode, "server.xml")
			if not os.path.isfile(self.options.os_xml):
				self.logger.critical('Server XML file does not exist: "%s"' % (self.options.os_xml,))
				sys.exit(1)

		will_start_client = self.task in ("client")
		if will_start_client and self.layout != OLD:
			self.options.os_xml = abspath(self.options.gda_config, "clients", self.options.profile, self.options.gda_mode, "client.xml")
			if not os.path.isfile(self.options.os_xml):
				self.logger.critical('Client XML file does not exist: "%s"' % (self.options.os_xml,))
				sys.exit(1)

		pids = []
		if self.task == "logpanel":
			pids.append(self.log_panel(debug_opts=debug_opts))
		elif self.task.find("logserver") >= 0:
			pids.append(self.log_server(debug_opts=debug_opts))
		elif self.task.find("nameserver") >= 0:
			pids.append(self.name_server(port=self.options.ns_port, debug_opts=debug_opts))
		elif self.task.find("namemanager") >= 0:
			pids.append(self.name_server_manager(port=self.options.ns_port, debug_opts=debug_opts))
		elif self.task.find("eventserver") >= 0:
			pids.append(self.event_server(debug_opts=debug_opts))
		elif self.task.find("objectserver") >= 0:
			pids.append(self.object_server(xmlfile=self.options.os_xml, debug_opts=debug_opts))
		
		elif self.task == "servers":
			
			if self.options.stop:
				self.stop_all_processes(pids, debug_opts)
			
			if self.options.start:
				self.start_all_processes(pids, debug_opts)
			
		
		elif self.task == "client":
			pids.append(self.client(xmlfile=self.options.os_xml, debug_opts=debug_opts))
		elif self.task == "rcpclient":
			pids.append(self.rcp_client(debug_opts=debug_opts))
		elif self.task == "userpermissions":
			pids.append(self.user_permissions())
			
		return pids

	def start_all_processes(self, pids, debug_opts):
		#force stop false
		old_options_stop = self.options.stop
		self.options.stop = False
		
		# DATAACQTEAM-154 check for eclipse osgi application startup
		if self.options.osgi:
			pids.append(self.servers_product(xmlfile=self.options.os_xml, debug_opts=debug_opts))
		else:
			pids.append(self.log_server())
			pids.append(self.name_server(port=self.options.ns_port))
			pids.append(self.event_server())
			pids.append(self.object_server(xmlfile=self.options.os_xml, debug_opts=debug_opts))
		# END
		self.options.stop = old_options_stop

	def stop_all_processes(self, pids, debug_opts):
		#force start False
		old_options_start = self.options.start
		self.options.start = False
		
		# DATAACQTEAM-154 check if the running instance is the eclipse osgi application variant
		if len(self.greplines(self.gda_osgi_process_matcher)) > 0:
			pids.append(self.servers_product(xmlfile=self.options.os_xml, debug_opts=debug_opts))
		else:
			pids.append(self.object_server(xmlfile=self.options.os_xml, debug_opts=debug_opts))
			pids.append(self.event_server())
			pids.append(self.name_server(port=self.options.ns_port))
			pids.append(self.log_server())
		# END
		self.options.start = old_options_start

	def get_commandlineArgs(self, argv):
		""" Read the command line arguments and perform some basic validation.
		"""

		self.define_parser()

		(self.options, args) = self.parser.parse_args(argv)

		if self.options.verbose:
			self.logger.setLevel(logging.DEBUG)  # log more
		if self.options.trace:
			self.logger.setLevel(1)  # log everything

		# --profile conflicts with -x
		if self.options.profile and self.options.os_xml:
			self.logger.critical("--osxml/-x cannot be used with --profile")
			sys.exit(1)
		if self.options.gda_mode:
			# --mode conflicts with -x
			if self.options.os_xml:
				self.logger.critical("--osxml/-x cannot be used with --mode")
				sys.exit(1)
			# --mode conflicts with --jacorb
			if self.options.jacorb_config_dir:
				self.logger.critical("--jacorb cannot be used with --mode")
				sys.exit(1)
			# --mode conflicts with --jca
			if self.options.jcalibrary_properties:
				self.logger.critical("--jca cannot be used with --mode")
				sys.exit(1)

		# if start/stop/restart not specified, default is to restart
		if self.options.start == None and self.options.stop == None:
			self.options.start = True

		# start implies stop and start
		if self.options.start:
			self.options.stop = True

		if self.options.version:
			return

		if len(args) != 1:
			self.usage()
			sys.exit(1)
		self.task = args[0]

		# check task name is valid
		if self.task not in self.server_tasks + self.client_tasks:
			self.logger.critical('GDA: unknown task "%s"' % (self.task,))
			sys.exit(1)

		# --foreground only valid when starting a single process
		if self.options.foreground:
			if self.task not in self.single_processes and not (self.options.start or self.options.stop):
				self.logger.critical('GDA: --foreground/-f can only be used when starting a single process')
				sys.exit(1)


	def _determine_first_valid_directory(self, path_function_list):
		""" Evaluate a list of functions that return a directory name, and return the first directory name that exists. or None.
		"""
		for path_function in path_function_list:
			if path_function:
				path = path_function()
				if not path:
					self.logger.trace('   skipping check of "%s" as an existing directory' % (path,))
				else:
					if not os.path.isdir(path):
						self.logger.trace('   checking if "%s" is an existing directory -- no' % (path,))
					else:
						self.logger.trace('   checking if "%s" is an existing directory - yes' % (path,))
						return path
		self.logger.trace('   no existing directory found in this check')
		return None


	def determine_operating_environment(self):
		""" Determine information about the OS & Java environment (not about GDA) 
		"""

		self.osIsWindows = os.name == 'nt'
		if self.osIsWindows : 
			javaFileName = "java.exe"
			jpsFileName = "jps.exe"
			self.libPath = "Path"
		else:
			javaFileName = "java"
			jpsFileName = "jps"
			self.libPath = "LD_LIBRARY_PATH"

		# Complain if JAVA_HOME is not set
		java_home = os.getenv("JAVA_HOME")
		if not java_home:
			self.logger.critical("You have not defined the JAVA_HOME environment variable.")
			sys.exit(1)

		# Check if JAVA_HOME is valid
		self.javabin = abspath(java_home, "bin", javaFileName)
		if not os.path.isfile(self.javabin):
			self.logger.critical('JAVA_HOME does not appear to point to a JRE or JDK - "%s" does not exist.' % (self.javabin,))
			sys.exit(1)
		self.jpsbin = abspath(java_home, "bin", jpsFileName)
		if not os.path.isfile(self.jpsbin):
			self.logger.critical('JAVA_HOME does not appear to point to a JRE or JDK - "%s" does not exist.' % (self.jpsbin,))
			sys.exit(1)

		# look for extra VM arguments
		if os.getenv("JAVA_OPTS"):
			self.options.java_opts = os.getenv("JAVA_OPTS").split(" ")
		else:
			self.options.java_opts = []

		# profiler
		if self.options.profiler:
			(self.profiler_jar, self.profiler_lib) = self.determine_profiler_settings()
			if not self.profiler_jar or not self.profiler_lib:
				self.options.profiler = False  # can't profile

		# get the name of library subdirectory for this platform
		if not self.options.lib_subdir:
			try:
				target_os = {'windows': 'win32', 'linux':'linux'}[platform.system().lower()]
			except KeyError:
				self.logger.critical('Cannot determine operating system from platform.system()="%s"' % (platform.system(),))
				self.logger.critical('Use the --lib_subdir option to specify correct name')
				sys.exit(1)
			try:
				target_arch = {'i686': 'x86', 'x86': 'x86', 'x86_64': 'x86_64', "AMD64": 'x86_64'}[platform.machine()]
			except KeyError:
				self.logger.critical('Cannot determine platform from platform.machine()="%s"' % (platform.machine(),))
				self.logger.critical('Use the --lib_subdir option to specify correct name')
				sys.exit(1)
			self.options.lib_subdir = '%s-%s' % (target_os, target_arch)


	def determine_profiler_settings(self):
		""" Determine Java profiler settings
		"""

		profiler_dir = os.getenv("PROFILER_DIR") or "/dls_sw/dasc/jprofiler5"

		# find architecture of Java binary, to work out which JProfiler library dir to use
		java_arch = platform.architecture(executable=self.javabin)[0]
		if java_arch == "32bit":
			jp_arch = "x86"
		elif java_arch == "64bit":
			jp_arch = "x64"
		else:
			self.logger.warning('Could not determine architecture of "%s" - JProfiler will default to 32-bit' % (self.javabin,))
			jp_arch = "x86"
		profiler_jar = abspath(profiler_dir, "bin", "agent.jar")
		profiler_lib = abspath(profiler_dir, "bin", "linux-%s" % (jp_arch,))

		self.logger.debug('JProfiler directory"%s"' % (profiler_dir,))
		self.logger.debug('JProfiler agent JAR is "%s"' % (profiler_jar,))
		self.logger.debug('JProfiler library directory is "%s"' % (profiler_lib,))

		if os.path.isfile(profiler_jar) and os.path.isdir(profiler_lib):
			return (profiler_jar, profiler_lib)
		else:
			self.logger.warning('JProfiler jar and/or library missing: skipping JProfiler')
			return (None, None)


	def determine_gda_configuration(self):
		""" Determine the location of the GDA configuration directory, trying possible locations in sequence.
			Determine the location of various items within the configuration directory.
			Determine various configuration options.
			See log_gda_configuration_and_data() for reporting this.
		"""

		# get path to configuration directory
		if self.options.gda_config:
			path = os.path.abspath(self.options.gda_config)
			if not os.path.isdir(path):
				self.logger.critical("Invalid location for the GDA configuration directory %s" % self.options.gda_config)
				sys.exit(1)
		else:
			self.logger.trace('attempting to determine location of GDA config directory')
			path = self._determine_first_valid_directory([
				lambda: os.getenv("GDA_WORKSPACE_PARENT") and os.getenv("GDA_INSTANCE_CONFIG_rel") and abspath(os.getenv("GDA_WORKSPACE_PARENT"), os.getenv("GDA_INSTANCE_CONFIG_rel")),
				lambda: os.getenv("GDA_CONFIG") and os.path.abspath(os.getenv("GDA_CONFIG")),
				lambda: os.getenv("BEAMLINE", None) not in [None, "BEAMLINE"] and abspath(self.gda_install_workspace_loc, os.getenv("BEAMLINE").lower() + "-config"),
				lambda: abspath(self.gda_install_workspace_loc, "config"),
				])
			if not path:
				self.logger.critical("Could not determine the location of the GDA configuration directory from one of the standard locations")
				self.logger.critical("You need to specify the location of the GDA configuration directory using --config or environment variables GDA_WORKSPACE_PARENT/GDA_INSTANCE_CONFIG_rel")
				sys.exit(1)
		self.options.gda_config = path
		
		# if clients/properties/servers folders exist, but not jacorb, then standard style folder structure is being used
		make_config_subdir = lambda subdir: abspath(self.options.gda_config, subdir)
		test_dirs = map(make_config_subdir, ("clients", "properties", "servers"))
		dirs_match = reduce(operator.and_, map(os.path.isdir, test_dirs))
		
		if dirs_match and not os.path.isdir(abspath(self.options.gda_config, "jacorb")):
			self.layout = STANDARD

		else:
				# if clients/jacorb/servers folders exist, then new style folder structure is being used
				test_dirs = map(make_config_subdir, ("clients", "jacorb", "servers"))
				dirs_match = reduce(operator.and_, map(os.path.isdir, test_dirs))
				if dirs_match:
					self.layout = NEW
				else:
					self.layout = OLD
					if self.options.gda_mode :
						self.logger.critical("You specified --mode=%s, but an old-style configuration was found at %s" % (self.options.gda_mode, os.path.abspath(self.options.gda_config)))
						sys.exit(1)

		# default profile is "main"
		if self.layout != OLD and not self.options.profile:
			self.options.profile = "main"

		# default mode is "live"
		if self.layout != OLD and not self.options.gda_mode:
			self.options.gda_mode = "live"

		# Set properties file, if not already set
		if not self.options.java_properties:
			if self.layout == OLD:
				self.options.java_properties = abspath(self.options.gda_config, "properties", "java.properties")
			elif self.layout == NEW:
				self.options.java_properties = abspath(self.options.gda_config, "properties", self.options.gda_mode, "java.properties")
			else: #self.layout == STANDARD
				# Using environment varaible set up in beamline specific gda bash script to locate java.properties
				self.logger.info("GDA_WORKSPACE_PARENT= %s" % os.getenv("GDA_WORKSPACE_PARENT"))
				self.logger.info("GDA_CORE_CONFIG_rel= %s" % os.getenv("GDA_CORE_CONFIG_rel"))
				
				self.options.gda_instance_config_dir = abspath(os.getenv("GDA_WORKSPACE_PARENT") +"/", os.getenv("GDA_INSTANCE_CONFIG_rel"))
				#Don't need to set variable below as only passing it straight through - See line : -Dgda.group.dir
				#self.options.gda_group_config_dir = abspath(os.getenv("GDA_WORKSPACE_PARENT") +"/", os.getenv("GDA_GROUP_CONFIG_rel"))
				self.logger.info("self.options.gda_instance_config_dir= %s" % self.options.gda_instance_config_dir)
				self.options.java_properties = abspath(self.options.gda_instance_config_dir, "properties", self.options.gda_mode, self.options.gda_mode + "_instance_java.properties")
		# Set JacORB config dir, if not already set
		if not self.options.jacorb_config_dir:
			if self.layout == OLD:
				self.options.jacorb_config_dir = abspath(self.options.gda_config, "properties")
			elif self.layout == NEW:
				self.options.jacorb_config_dir = abspath(self.options.gda_config, "jacorb", self.options.gda_mode)
			else: #self.layout == STANDARD
				self.options.jacorb_config_dir = abspath(self.options.gda_config, "properties", self.options.gda_mode, "jacorb")
			

			
		# Set JCA properties file, if not already set
		if not self.options.jcalibrary_properties:
			if self.layout == OLD:
				self.options.jcalibrary_properties = abspath(self.options.gda_config, "properties", "JCALibrary.properties")
			elif self.layout == NEW:
				self.options.jcalibrary_properties = abspath(self.options.gda_config, "jca", self.options.gda_mode, "JCALibrary.properties")
			else: #self.layout == STANDARD
				self.options.jcalibrary_properties = abspath(self.options.gda_config, "properties", self.options.gda_mode, "JCALibrary.properties")
				
			
	def determine_gda_data(self):
		""" Determine the location of the GDA data directory.
			Specifying the location is optional. If not set, a gda.data property will need to be defined in the java.properties file.
			See log_gda_configuration_and_data() for reporting this.
		"""

		if not self.options.gda_data and os.getenv("GDA_DATADIR"):
			self.options.gda_data = os.getenv("GDA_DATADIR")

		if self.options.gda_data:
			path = os.path.abspath(self.options.gda_data)
			if not os.path.isdir(path):
				self.logger.critical("Invalid location for the GDA data directory %s" % self.options.gda_data)
				sys.exit(1)
			self.options.gda_data = path


	def log_gda_configuration_and_data(self):
		""" Log the GDA environment as discovered by determine_gda_configuration() and determine_gda_data()
		"""

		self.logger.debug("<< GDA configuration details >>")
		item_description = [ ("gda.config", self.options.gda_config) ]
		item_description.append(('layout', self.layout))
		if self.layout != OLD:
			item_description.append(('profile', self.options.profile))
			item_description.append(('mode', self.options.gda_mode))
		item_description.append(("gda.install.workspace.loc", self.gda_install_workspace_loc))
		item_description.append(("gda.install.git.loc", self.gda_install_git_loc))
		item_description.append(("gda.data", self.options.gda_data or "Will be taken from the java.properties file - if it is missing, then GDA may not work"))
		item_description.append(("gda.var", self.options.gda_var or "Will be taken from the java.properties file - if it is missing, then GDA may not work"))
		item_description.append(("gda_logdir", self.options.gda_logdir or "gda.logs.dir will be taken from the java.properties file"))
		item_description.append(("java.properties", self.options.java_properties))
		item_description.append(("jacorb.config.dir", self.options.jacorb_config_dir))
		item_description.append(("gov.aps.jca.JCALibrary.properties", self.options.jcalibrary_properties))
		for item, description in item_description:
			self.logger.debug("%-25s: %s" % (item, description))


	def determine_gda_environment(self):
		""" Determine the location of various GDA directories. Not all these are necessarily used.
			Most of these default, but can be overridden with either an environment variable, or an command line option.
			Determine various other items. Not all these are necessarily used.
		"""

		plugin_locations = {}  # key=plugin name, value=list of paths where this plug can be fouund (should only be 1)

		parents = []  # a list of directories whose subdirectories might be plugins
		parents.append(self.gda_install_git_loc)
		for repo in os.listdir(self.gda_install_git_loc):
			pathToRepo = abspath(self.gda_install_git_loc, repo)
			if os.path.isdir(pathToRepo):
				parents.append(pathToRepo)
				for repo1 in os.listdir(pathToRepo):
					if repo1.startswith("."):
						continue
					child = abspath(pathToRepo, repo1)
					if os.path.isdir(child):
						parents.append(child)

		for parent in parents:
			for plugin in os.listdir(parent):
				if plugin.startswith("."):
					continue
				if os.path.isfile(abspath(parent, plugin, "META-INF", "MANIFEST.MF")):
					if not plugin in plugin_locations:
						plugin_locations[plugin] = [abspath(parent, plugin)]
					else:
						plugin_locations[plugin].append(abspath(parent, plugin))

		self.plugin_location = {}
		self.logger.trace('<< Plugin locations >>')
		for p, locs in sorted(plugin_locations.iteritems()):
			if len(locs) <> 1:
				self.logger.warning('Plugin %s appears in multiple locations: %s' % (p, locs))
			self.plugin_location[p] = locs[0]  # select the first location, which will be the git checkout
			self.logger.trace('   %-51s %s' % (p, locs[0]))

		self.tp = abspath(self.gda_install_workspace_loc, 'tp')

		tp_signature_dir = abspath(self.tp, 'plugins')

		if not os.path.isdir(tp_signature_dir):
			self.logger.critical("target platform %s does not exist" % (tp_signature_dir,))
			sys.exit(1)

	def build_class_path_and_library_path(self):
		""" Builds the class path and library path for server process(s) and the non-RCP client.
		"""

		self.gda_class_path_list = []
		self.library_path = []

		self.server_dependents_to_ignore = [
			"system.bundle",
			"org.python.pydev", "org.python.pydev.core", "org.python.pydev.debug", "org.python.pydev.ast",
			"org.python.pydev.customizations", "org.python.pydev.help", "org.python.pydev.jython",
			"org.python.pydev.parser", "org.python.pydev.refactoring",
			"com.python.pydev", "com.python.pydev.analysis", "com.python.pydev.codecompletion", "com.python.pydev.debug",
			"com.python.pydev.fastparser", "com.python.pydev.refactoring", "ch.qos.logback.eclipse", "ch.qos.logback.beagle"]

		# uk.ac.gda.core needs special handling, since it uses classes/ rather than the standard bin/
		location = self.plugin_location["uk.ac.gda.core"]
		self.append_to_class_path(os.path.join(location, "classes", "main"))
		if self.options.testing:
			self.append_to_class_path(os.path.join(location, "classes", "test"))
		self.append_to_class_path(os.path.join(location, "jars", "*"))
		plugin_lib = os.path.join(location, "lib", self.options.lib_subdir)
		if os.path.isdir(plugin_lib) and [item for item in os.listdir(plugin_lib) if not item.startswith('.')]:
			self.append_to_library_path(plugin_lib)

		location = self.plugin_location["uk.ac.diamond.jython"]
		jythonJarPath = os.path.join(location, "jython2.5", "jython.jar")
		if not os.path.exists(jythonJarPath):
			self.logger.critical("Jython  %s does not exist" % (jythonJarPath,))
			sys.exit(1)
						
		self.append_to_class_path(os.path.join(location, "jython2.5", "jython.jar"))
		if not self.options.smart:
			# be dumb - just add in all projects, plus tp/various
			location = self.plugin_location["uk.ac.gda.libs"]
			self.append_to_class_path(os.path.join(location, "*"))

			for plugin, location in sorted(self.plugin_location.iteritems()):
				if plugin in ("uk.ac.gda.core", "uk.ac.gda.libs"):
					continue
				if plugin.endswith(".test") and not self.options.testing:
					continue

				self.append_single_plugin_to_class_path_and_library_path(location)

			tp_bundles = os.path.join(self.tp, "plugins")
			if os.path.isdir(tp_bundles) and [item for item in os.listdir(tp_bundles) if not item.startswith('.')]:
				self.append_to_class_path(os.path.join(tp_bundles, "*"))

		else:
			location = self.plugin_location["uk.ac.gda.libs"]
			self.append_to_class_path(os.path.join(location, "*"))
# 			self.append_to_class_path( os.path.join(location, "jython2.5.1","jython.jar") )

			# be smart - just add plugins listed as dependencies in the CSpec for the GDA configuration
			self.plugin_parser = PluginData(self.options.lib_subdir)  # for extracting information from a plugin manifest
			self.dependents_already_processed = []
			self.append_plugin_and_dependencies_to_class_path_and_library_path("uk.ac.gda.core")
			cspec_path = os.path.join(self.options.gda_config, "buckminster.cspec")
			if os.path.exists(cspec_path):
				doc = minidom.parse(cspec_path)
				for entry in doc.getElementsByTagName('cs:dependency'):
					if entry.getAttribute('componentType') == "osgi.bundle":
						dependent = entry.getAttribute('name')
						if not ((self.task in self.server_tasks) and (dependent in self.server_dependents_to_ignore)):
							self.append_plugin_and_dependencies_to_class_path_and_library_path(dependent)

		# add any classes and jars from the configuration
		config_classes = abspath(self.options.gda_config, "classes")
		if os.path.isdir(config_classes) and [item for item in os.listdir(config_classes) if not item.startswith('.')]:
			self.append_to_class_path(config_classes)
		config_jars = abspath(self.options.gda_config, "jars")
		if os.path.isdir(config_jars) and [item for item in os.listdir(config_jars) if not item.startswith('.')]:
			self.append_to_class_path(os.path.join(config_jars, "*"))

		self.logger.trace("<< Class Path >>")
		for item in self.gda_class_path_list:
			self.logger.trace('   %s' % (item,))
		self.logger.trace("<< Library Path >>")
		for item in self.library_path:
			self.logger.trace('   %s' % (item,))

		self.gda_class_path = os.pathsep.join(self.gda_class_path_list)
		self.gda_class_path_list = None  # so it's not reused

	def append_single_plugin_to_class_path_and_library_path(self, plugin):
		""" Appends bin/ and jars/ for the plugin, if they exist, to the class path
			Appends the lib/ subdir, if it exists, to the library path
		"""
		self.logger.trace("append_single_plugin_to_class_path_and_library_path called for: %s" % (plugin,))
		plugin_bin = os.path.join(plugin, "bin")
		if os.path.isdir(plugin_bin) and [item for item in os.listdir(plugin_bin) if not item.startswith('.')]:
			self.append_to_class_path(plugin_bin)
		plugin_jars = os.path.join(plugin, "jars")
		if os.path.isdir(plugin_jars) and [item for item in os.listdir(plugin_jars) if not item.startswith('.')]:
			self.append_to_class_path(os.path.join(plugin_jars, "*"))
		plugin_lib = os.path.join(plugin, "lib", self.options.lib_subdir)
		if os.path.isdir(plugin_lib) and [item for item in os.listdir(plugin_lib) if not item.startswith('.')]:
			self.append_to_library_path(plugin_lib)

	def append_to_class_path(self, item):
		""" Appends a single item to the class path
		"""
		if item:
			assert item not in self.gda_class_path_list  # if we try and add something twice, there is an error in the logic somewhere
			self.logger.trace("adding to class path: %s" % (item,))
			self.gda_class_path_list.append(item)

	def append_to_library_path(self, item):
		""" Appends a single item to the library path
		"""
		if item:
			if item not in self.library_path:
				self.logger.trace("adding to library path: %s" % (item,))
				self.library_path.append(item)

	def append_plugin_and_dependencies_to_class_path_and_library_path(self, dependent):
		""" Given a plugin (dependent), recursively updates self.gda_class_path_list with this plugin and all its dependencies in turn.
			Keeps track of which plugin we have processed to ensure that we don't recurse forever. 
		"""

		self.logger.trace("append_plugin_and_dependencies_to_class_path_and_library_path called for: %s" % (dependent,))
		if dependent in self.dependents_already_processed:
			return
		self.dependents_already_processed.append(dependent)

		if dependent == "org.junit4":
			junit_template = abspath(self.tp, "plugins", "org.junit_4*", "junit.jar")
			for path in glob.glob(junit_template):
				self.append_to_class_path(path)
			return  # don't look for junit dependencies

		location = self.plugin_location.get(dependent)
		if location:
			# handle a regular (non-target-platform plugin)
			self.append_single_plugin_to_class_path_and_library_path(location)
			self.plugin_parser.setup(location)
			dependencies = self.plugin_parser.requireBundleSection()  # look in manifest for other dependencies
			if self.options.testing:
				testDependent = dependent + ".test"
				if self.plugin_location.get(dependent):
					dependencies.append(testDependent)
			for dependency in dependencies:
				if dependency not in self.dependents_already_processed:
					if not ((self.task in self.server_tasks) and (dependency in self.server_dependents_to_ignore)):
						self.append_plugin_and_dependencies_to_class_path_and_library_path(dependency)

		else:
			if dependent == 'uk.ac.diamond.org.jscience4':
				# There are 2 versions of jscience (2.0.2 and 4.3.1) in tp/ and the classpath order is important
				# 2.0.2 (bundle name uk.ac.diamond.org.jscience) must appear before 4.3.1 (bundle name uk.ac.diamond.org.jscience4)
				# so if we are adding jscience4, first add jscience (the code makes sure that we never add anything twice)
				self.append_plugin_and_dependencies_to_class_path_and_library_path('uk.ac.diamond.org.jscience')
			# look up a jar in tp/plugins
			jarPaths = glob.glob(os.path.join(self.tp, "plugins", dependent + "_*.jar"))  # use * in place of version numbers
			if len(jarPaths) > 1:
				self.logger.warn("Multiple jars satisfy %s: %s" % (dependent, jarPaths))
			if len(jarPaths) >= 1:
				for jarPath in sorted(jarPaths):
					self.append_to_class_path(jarPath)
			else:
				rcpclient_required_dependent = ["org.python.pydev", "org.python.pydev.core", "org.python.pydev.debug", "org.python.pydev.ast", "org.python.pydev.customizations", "org.python.pydev.help", "org.python.pydev.jython", "org.python.pydev.parser", "org.python.pydev.refactoring", "com.python.pydev", "com.python.pydev.analysis", "com.python.pydev.codecompletion", "com.python.pydev.debug", "com.python.pydev.fastparser", "com.python.pydev.refactoring", "ch.qos.logback.eclipse", "ch.qos.logback.beagle"]
				# Only RCP client requires these bundles so become critial - a real hack, need a better solution.
				if self.task == "rcpclient" and dependent in rcpclient_required_dependent:
					self.logger.critical("Cannot find dependent: %s" % (dependent,))



	def addToLd_Library_Path(self, path):
		""" Adds native libraries to LD_LIBRARY_PATH (Linux) or Path (Windows).
		"""

		if not os.path.exists(path):
			self.logger.critical('Library path "%s" does not exist. Use --lib_subdir option to specify correct path' % (path,))
			sys.exit(1)

		if self.libPath not in os.environ:
			# Must not set to '$LD_LIBRARY_PATH:/new/path' in this case, or we
			# end up with the current directory on the path.
			newvalue = path
		else:
			newvalue = os.environ[self.libPath] + os.pathsep + path

		self.gdaos.putenv(self.libPath, newvalue)
		self.logger.debug("adding to %s: %s " % (self.libPath, path))

	# DATAACQTEAM-154 
	def greplines(self, grep_phrases):
		a = self.gdaos.popen_get_stdout("ps -u `whoami` -f --cols 6000 | grep -F -e '%s' | grep -v grep " % grep_phrases[0], False)
		return a.readlines()
		
	def build_debugArgs(self, debug_opts=None):
		vmargs_debug = ()
		if debug_opts and debug_opts["debug"]:
			suspend = "n"
			if debug_opts["debug_suspend"]:
				suspend = "y"
			vmargs_debug = (
				"-Xdebug",
				"-Xrunjdwp:transport=dt_socket," + 
				"address=" + str(debug_opts["debug_port"]) + 
				",server=y,suspend=" + suspend,)
		return vmargs_debug
	# END

	def getpids(self, grep_phrases, use_jps):
		if len(grep_phrases) == 0:
			raise "getpids - grep_phrases is empty)"
		pids = ()
		if(self.osIsWindows):
			a = self.gdaos.popen_get_stdout('"%s" -vl' % self.jpsbin, False)  # quotes around jpsPath in case of embedded blanks
			lines = a.readlines()
			print "pid lines are "
			print lines
			if self.options.verbose :
				print lines
			for line in lines:
				print line
				line = line.strip()
				parts = line.split()
				pidpart = parts[0]
				allfound = True 
				for grep_phrase in grep_phrases:
					if not grep_phrase in parts:
						allfound = False
						# print "not Match ", grep_phrase
						break
				if allfound:
					pids += (int(parts[0]),)
		else:
			if use_jps:
				a = self.gdaos.popen_get_stdout("%s -lm | grep %s" % (self.jpsbin, grep_phrases[0]), False)
				lines = a.readlines()
				self.logger.debug("getpids: jps returned %s" % (lines,))
				for line in lines:
					
					# skip objectservers with different profiles
					if self.options.profile:
						m = re.search("\s-p\s([a-z]+)", line)
						if m and m.group(1) != self.options.profile:
							continue # i.e skip adding this pid to the list to be killed when killing old processes
					pids += (int(line.split()[0]),)
			else:
				lines = self.greplines(grep_phrases)     # DATAACQTEAM-154
				self.logger.debug("getpids: grep returned %s" % (lines,))
				for line in lines :
					line = line.strip()
					parts = line.split()
					allfound = True 
					for grep_phrase in grep_phrases:
						if not grep_phrase in parts:
							allfound = False
							break
					if allfound:
						pids += (int(parts[1]),)
		self.logger.debug("getpids: found pids %s" % (pids,))
		return pids

	def kill_process(self, grep_phrases, use_jps=False, send_quit=False):
		"""
		grep_phrases (a misnomer) is a list of strings, which together identify which pid(s) to kill.
		use_jps=True says that the process to kill is a java process, so use "jps" to identify the pid(s) to kill.
		use_jps=False says to use "ps", and grep over the output, to identify the pid(s) to kill.
		Although the code below attempts to work on Windows, this is unsupported and untested, and will probably be removed in future.
		"""

		self.logger.debug("kill_process entered for %s" % (grep_phrases,))
		if(self.osIsWindows):
			print grep_phrases
			pids = self.getpids(grep_phrases, use_jps)
			for pid in pids:
				if not self.options.dry_run:
					try:
						print "trying to kill process with pid " , str(pid)
						os.system("tskill " + str(pid))
					except:
						type, exception, traceback = sys.exc_info()
						print "Exception raised when trying to kill process %s. %s" % (pid, exception)
						print "You may not have privilege"
						return False
		else:
			signals = [signal.SIGTERM, signal.SIGKILL]
			
			# sending the quit signal to the VM process produces a thread dump
			if send_quit:
				signals = [signal.SIGQUIT] + signals

			for sig in signals:
				pids = self.getpids(grep_phrases, use_jps)
				if not pids:
					return True
				for pid in pids:
					self.logger.debug("About to kill process %d with signal %d" % (pid, sig))
					if not self.options.dry_run:
						try:
							os.kill(pid, sig)
						except Exception as fault:
							exc_type = sys.exc_info()[0]
							self.logger.critical("Exception raised when trying to kill process %s: %s %s" % (pid, exc_type, fault))
							return False
				if sig != signal.SIGKILL:
					time.sleep(3)
				else:
					time.sleep(7)
		if self.options.dry_run:
			return True
		pids = self.getpids(grep_phrases, use_jps)
		for pid in pids:
			self.logger.critical("Unable to kill process %s" % (pid,))
		return len(pids) == 0


	def java(self, class_path, class_name, prevmargs=(), vmargs=(), args=(), wait=False, debug_opts=None):
		old_class_path = os.getenv("CLASSPATH")
		if old_class_path == None:
			new_class_path = class_path
			old_class_path = ""
		else:
			new_class_path = class_path + os.pathsep + old_class_path
		self.gdaos.putenv("CLASSPATH", new_class_path)
		self.logger.debug("setting CLASSPATH to %s" % new_class_path)
		class_name_tuple = (class_name,)
		pid = self.start_process(self.javabin, prevmargs, vmargs, class_name_tuple + args, wait, debug_opts)
		# Reset to old value so that future calls to java are not affected by this one
		self.gdaos.putenv("CLASSPATH", old_class_path)
		return pid

	def start_process(self, imagePath, prevmargs=(), vmargs=(), args=(), wait=False, debug_opts=None):
		
		# Add plugin native libraries to library path
		for plugin_lib_path in self.library_path:
			self.addToLd_Library_Path(plugin_lib_path)

		vmargs_tuple = tuple(self.options.java_opts)
		vmargs_tuple += self.build_debugArgs(debug_opts)  # DATAACQTEAM-154
			
		if self.options.profiler:
			vmargs_profiler = (
				"-agentlib:jprofilerti=port=" + str(self.options.profiler_port),
				"-Xbootclasspath/a:" + self.profiler_jar
				) 
			vmargs_tuple += vmargs_profiler
			self.addToLd_Library_Path(self.profiler_lib)
			
		vmargs_tuple += vmargs
		
		if self.options.foreground:
			self.gdaos.run_in_foreground(imagePath, prevmargs + vmargs_tuple + args, self.options.dry_run)
		elif wait :
			return self.gdaos.runcmd_get_stdout(imagePath , prevmargs + vmargs_tuple + args, self.options.dry_run)
		else :
			return self.gdaos.spawn_nowait(imagePath , prevmargs + vmargs_tuple + args, self.options.dry_run)

	def stop_start_java(self, classpath, class_name, vmargs=(), args=(), sleep=0, debug_opts=None):
		if self.options.stop and not self.kill_process((class_name,), use_jps=True, send_quit=self.options.threaddump):
			return 0
		if not self.options.start:
			return 0
		pid = self.java(classpath, class_name , vmargs=vmargs, args=args, debug_opts=debug_opts)
		if sleep <> 0 and not self.options.dry_run:
			time.sleep(sleep)
		return pid
	
	def stop_start_process(self, imagePath, prevmargs=(), vmargs=(), args=(), debug_opts=None):
		if self.options.stop and not self.kill_process((os.path.realpath(imagePath),) + args):
			return 0
		if not self.options.start:
			return 0
		pid = self.start_process(imagePath, prevmargs, vmargs, args, debug_opts=debug_opts)
		return pid
			
	def addOptionalVMArgs(self, vmargs):
		# the following are only added if they have been defined, else should be defined in the java.properties file
		if self.options.gda_logdir != None:
			vmargs += ("-Dgda.logs.dir=" + self.options.gda_logdir,)
		if self.options.gda_data != None:
			vmargs += ("-Dgda.data=" + self.options.gda_data,)
		if self.options.gda_var != None:
			vmargs += ("-Dgda.var=" + self.options.gda_var,)
		if self.options.gda_mode != None:
			vmargs += ("-Dgda.mode=" + self.options.gda_mode,)
		if self.options.java_properties != None:
			vmargs += ("-Dgda.propertiesFile=" + self.options.java_properties,)
		if self.layout == STANDARD:
			vmargs += ("-Dgda.core.dir=" + abspath(os.getenv("GDA_WORKSPACE_PARENT") +"/",os.getenv("GDA_CORE_CONFIG_rel")),)
			vmargs += ("-Dgda.facility.dir=" + abspath(os.getenv("GDA_WORKSPACE_PARENT") +"/",os.getenv("GDA_FACILITY_CONFIG_rel")),)
			vmargs += ("-Dgda.group.dir=" + abspath(os.getenv("GDA_WORKSPACE_PARENT") +"/",os.getenv("GDA_GROUP_CONFIG_rel")),)
			vmargs += ("-Dgda.instance.dir=" + abspath(os.getenv("GDA_WORKSPACE_PARENT") +"/",os.getenv("GDA_INSTANCE_CONFIG_rel")),)
		return vmargs

	def log_panel(self, debug_opts=None):
		class_name = "gda.util.LogPanel"
		vmargs = (
					"-Dgda.install.workspace.loc=" + self.gda_install_workspace_loc,
					"-Dgda.install.git.loc=" + self.gda_install_git_loc,
					"-Dgda.config=" + self.options.gda_config,
				)
		
		swingclient_bin_path = os.path.join(self.gda_install_git_loc, "gda-legacy.git", "uk.ac.gda.swingclient", "bin")
		class_path = self.gda_class_path + os.pathsep + swingclient_bin_path
		
		vmargs = self.addOptionalVMArgs(vmargs)
		return self.stop_start_java(class_path, class_name , vmargs=vmargs, debug_opts=debug_opts)

	def log_server(self, debug_opts=None):
		class_name = "gda.util.LogServer"
		vmargs = (
					"-Dgda.install.workspace.loc=" + self.gda_install_workspace_loc,
					"-Dgda.install.git.loc=" + self.gda_install_git_loc,
					"-Dgda.config=" + self.options.gda_config
		)
		vmargs = self.addOptionalVMArgs(vmargs)
		return self.stop_start_java(self.gda_class_path, class_name , vmargs=vmargs, sleep=2, debug_opts=debug_opts)
	
	def name_server(self, port, debug_opts=None):
		class_name = "org.jacorb.naming.NameServer"
		vmargs = (
					"-Djacorb.config.dir=" + self.options.jacorb_config_dir,
					"-Dorg.omg.CORBA.ORBClass=org.jacorb.orb.ORB",
					"-Dorg.omg.CORBA.ORBSingletonClass=org.jacorb.orb.ORBSingleton",
					"-DOAPort=" + str(port)
				)
		return self.stop_start_java(self.gda_class_path, class_name , vmargs=vmargs, sleep=2, debug_opts=debug_opts)

	
	def name_server_manager(self, port, debug_opts=None):
		class_name = "org.jacorb.naming.namemanager.NameManager"
		vmargs = (
					"-Djacorb.config.dir=" + self.options.jacorb_config_dir,
					"-Dorg.omg.CORBA.ORBClass=org.jacorb.orb.ORB",
					"-Dorg.omg.CORBA.ORBSingletonClass=org.jacorb.orb.ORBSingleton",
					"-DOAPort=" + str(port)
				)
		if self.options.gda_logdir != None:
			vmargs += ("-Dgda.logs.dir=" + self.options.gda_logdir,)
		return self.stop_start_java(self.gda_class_path, class_name , vmargs=vmargs, sleep=2, debug_opts=debug_opts)

	def event_server(self, debug_opts=None):
		class_name = "gda.factory.corba.util.ChannelServer"
		vmargs = (
					"-Dgda.install.workspace.loc=" + self.gda_install_workspace_loc,
					"-Dgda.install.git.loc=" + self.gda_install_git_loc,
					"-Dgda.config=" + self.options.gda_config,
					"-Djacorb.config.dir=" + self.options.jacorb_config_dir,
				)
		vmargs = self.addOptionalVMArgs(vmargs)
		return self.stop_start_java(self.gda_class_path, class_name , vmargs=vmargs, sleep=2, debug_opts=debug_opts)

	def object_server(self, xmlfile="", debug_opts=None):
		class_name = "gda.util.ObjectServer"
		args = ()
		if xmlfile != None:
			args = ("-f", xmlfile)
			if self.options.profile:
				args = args + ("-p", self.options.profile)
		vmargs = (
					"-Dgda.install.workspace.loc=" + self.gda_install_workspace_loc,
					"-Dgda.install.git.loc=" + self.gda_install_git_loc,
					"-Dgda.config=" + self.options.gda_config,
					"-Djacorb.config.dir=" + self.options.jacorb_config_dir,
					"-Dgov.aps.jca.JCALibrary.properties=" + self.options.jcalibrary_properties,
					"-Dderby.stream.error.field=gda.util.persistence.LocalObjectShelfManager.DerbyLogStream",
					)
		vmargs = self.addOptionalVMArgs(vmargs)
		if self.options.headless:
			vmargs += ("-Djava.awt.headless=true",)
		return self.stop_start_java(self.gda_class_path, class_name , vmargs=vmargs, args=args, debug_opts=debug_opts)

	# DATAACQTEAM-154 Starts/stops the log, name, channel/event and object servers as an 
	# eclipse osgi application only in response to the command gda --osgi servers
	#
	def servers_product(self, xmlfile="", debug_opts=None):
		if self.options.stop and not self.kill_process((self.gda_osgi_process_matcher), send_quit=self.options.threaddump):
			return 0
		if not self.options.start:
			filename = os.getenv("OBJECT_SERVER_STARTUP_FILE")
			if filename:
				open(filename, "wb").close()
			return 0
		args = ()
		if xmlfile != None:
			args = ("-f", xmlfile)
			if self.options.profile:
				args = args + ("-p", self.options.profile)
		vmargs = (
					"-Dgda.install.workspace.loc=" + self.gda_install_workspace_loc,
					"-Dgda.install.git.loc=" + self.gda_install_git_loc,
					"-Dgda.config=" + self.options.gda_config,
					"-Djacorb.config.dir=" + self.options.jacorb_config_dir,
					"-Dgov.aps.jca.JCALibrary.properties=" + self.options.jcalibrary_properties,
					"-Dderby.stream.error.field=gda.util.persistence.LocalObjectShelfManager.DerbyLogStream",
					# These args identify that we are using the osgi application and overcome the rmi classloading problem
					"-Dosgi.gda.application=true",
					"-Djava.ext.dirs=" + self.gda_install_springframework_jars_loc,
					)
		vmargs = self.addOptionalVMArgs(vmargs)
		if self.options.headless:
			vmargs += ("-Djava.awt.headless=true",)
		vmargs += self.build_debugArgs(debug_opts)			
		return self.gdaos.spawn_nowait(self.gda_install_product, args + ("-vmargs",) + vmargs, False)
	# END

	def client(self, xmlfile="", debug_opts=None):
		class_name = "gda.gui.AcquisitionGUI"		
		vmargs = (
					"-Dgda.install.workspace.loc=" + self.gda_install_workspace_loc,
					"-Dgda.install.git.loc=" + self.gda_install_git_loc,
					"-Dgda.config=" + self.options.gda_config,
					"-Djacorb.config.dir=" + self.options.jacorb_config_dir,
					"-Dgov.aps.jca.JCALibrary.properties=" + self.options.jcalibrary_properties
				)
		vmargs = self.addOptionalVMArgs(vmargs)
		
		args = ()
		if xmlfile != None:
			args = ("-f", xmlfile)		
		if self.options.nosplash:
			args += ("-nosplash",)
		
		return self.stop_start_java(self.gda_class_path, class_name , vmargs=vmargs, args=args, debug_opts=debug_opts)

	def rcp_client(self, debug_opts=None):
		vmargs = (
					"-Dgda.install.workspace.loc=" + self.gda_install_workspace_loc,
					"-Dgda.install.git.loc=" + self.gda_install_git_loc,
					"-Dgda.config=" + self.options.gda_config,
					"-Djacorb.config.dir=" + self.options.jacorb_config_dir,
					"-Dgov.aps.jca.JCALibrary.properties=" + self.options.jcalibrary_properties
				)
		vmargs = self.addOptionalVMArgs(vmargs)
		if self.options.rcp_image == None:
			self.options.rcp_image = abspath(self.options.gda_config, "eclipse", "gda")
			if not os.path.exists(self.options.rcp_image):
				self.logger.critical('Attempting to run RCP image that does not exist: "%s"' % (self.options.rcp_image,))
				sys.exit(1)
		return self.stop_start_process(self.options.rcp_image, prevmargs=("-vmargs",), vmargs=vmargs, debug_opts=debug_opts)

	def user_permissions(self, xmlfile="", debug_opts=None):
		class_name = "gda.jython.authoriser.EditPermissions"
		vmargs = (
				"-Dgda.install.workspace.loc=" + self.gda_install_workspace_loc,
				"-Dgda.install.git.loc=" + self.gda_install_git_loc,
				"-Dgda.config=" + self.options.gda_config
				)
		args = ()
		return self.stop_start_java(self.gda_class_path, class_name , vmargs=vmargs, args=args, debug_opts=debug_opts)

	def get_version(self):
		""" method that can call onto a class to test the system works
		"""
		vmargs = (
					"-Dgda.install.workspace.loc=" + self.gda_install_workspace_loc,
					"-Dgda.install.git.loc=" + self.gda_install_git_loc,
					"-Dgda.config=" + self.options.gda_config,
					"-Djacorb.config.dir=" + self.options.jacorb_config_dir,
					"-Dgov.aps.jca.JCALibrary.properties=" + self.options.jcalibrary_properties
				)
		vmargs = self.addOptionalVMArgs(vmargs)

		class_name = "gda.util.GDALauncherHelper"
		class_path = self.gda_class_path + os.pathsep + os.path.join(self.gda_install_git_loc, "gda-core.git", "uk.ac.gda.core", "classes", "test")
		outputFilePath = "TestStartupScript_Output.py"
		verbose = self.options.verbose
		self.options.verbose = False
		a = self.java(class_path, class_name, vmargs=vmargs, args=(outputFilePath,), wait=True)
		self.options.verbose = verbose
		if self.options.dry_run:
			return 
		lines = a.readlines()
		self.logger.debug("get_version: lines=%s" % (lines,))
		script = ""
		for line in lines:
			script += line
		exec(script)
		class_path_returned = eval("TestStartupScript_result[\"CLASSPATH\"]")
		if repr(class_path) != repr(class_path_returned):
			self.logger.critical("get_version: returned incorrect classpath")
			self.logger.critical("class_path_returned: %s" % (class_path_returned,))
			self.logger.critical("class_path         : %s" % (class_path,))
			return "Error get_version returned incorrect classpath"
		else:
			return eval("TestStartupScript_result[\"Release\"]")

def main(argv):
	define_loggers()
	return GdaLauncher().mainline(sys.argv[1:])

if __name__ == '__main__':
	print main(sys.argv[1:])
