/*-
 * Copyright Â© 2022 Diamond Light Source Ltd.
 *
 * This file is part of GDA.
 *
 * GDA is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 as published by the Free
 * Software Foundation.
 *
 * GDA is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along
 * with GDA. If not, see <http://www.gnu.org/licenses/>.
 */

package uk.ac.diamond.daq.mapping.ui.experiment;

import java.util.List;
import java.util.UUID;

import org.eclipse.scanning.api.points.GeneratorException;
import org.eclipse.scanning.api.points.IPointGenerator;
import org.eclipse.scanning.api.points.IPointGeneratorService;
import org.eclipse.scanning.api.points.models.IAxialModel;
import org.eclipse.scanning.api.points.models.IMapPathModel;
import org.eclipse.scanning.api.points.models.IScanPathModel;
import org.eclipse.scanning.api.points.models.TwoAxisGridPointsModel;
import org.eclipse.scanning.api.points.models.TwoAxisGridStepModel;
import org.eclipse.scanning.api.points.models.TwoAxisLinePointsModel;
import org.eclipse.scanning.api.points.models.TwoAxisLineStepModel;
import org.eclipse.scanning.device.ui.ServiceHolder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import uk.ac.diamond.daq.mapping.api.IMappingScanRegionShape;
import uk.ac.diamond.daq.mapping.api.document.scanpath.PathInfo;
import uk.ac.diamond.daq.mapping.region.CentredRectangleMappingRegion;
import uk.ac.diamond.daq.mapping.region.LineMappingRegion;
import uk.ac.diamond.daq.mapping.region.RectangularMappingRegion;


/**
 * Class that calculates the total number of points for some use cases of {@link IScanPathModel} and {@link IMappingScanRegionShape}.
 * For example, a rectangle with a grid. This is used by {@link StatusPanel} to update the total number of points quickly before the {@link PathInfo}
 * information from the {@link IScanPathModel} is obtained which can be slow for large maps. The StatusPanel checks if the points of the
 * scanPathModel and scanRegionShape objects can be calculated and, performs different calculations depending on whether the scanPathModel is a grid
 * or a step model. The total number of inner points is then multiplied by the outer points.
 * This class has an event id generated by the {@link RegionAndPathController} that is checked against the {@link PathInfo} object event id.
 * If the ids match, the PathInfo information is displayed. If they are not equal, they do not belong to the same event and StatusPanel will display the quick
 * results generated by this class and this will be overwritten with the PathInfo results later on.
 **/

public class ScanPointsCalculator {

	private UUID eventId;
	private IScanPathModel scanPathModel;
	private IMappingScanRegionShape scanRegionShape;
	private List<IAxialModel> outerScannables;
	private final IPointGeneratorService pointGeneratorService;

	private static final Logger logger = LoggerFactory.getLogger(ScanPointsCalculator.class);

	public ScanPointsCalculator(IScanPathModel scanPathModel, IMappingScanRegionShape scanRegionShape, List<IAxialModel> outerScannables) {
		this.scanPathModel = scanPathModel;
		this.scanRegionShape = scanRegionShape;
		this.outerScannables = outerScannables;
		pointGeneratorService = ServiceHolder.getGeneratorService();
	}

	public String getUnits() {
		if (scanPathModel instanceof IMapPathModel) {
			return ((IMapPathModel) scanPathModel).getxAxisUnits();
		}
		return "";
	}

	public boolean canCalculateScanPoints() {
		return isPathValid() && isRegionValid();
	}

	public int calculateScanPoints() {
		return calculateInnerPoints() * calculateAllOuterPoints();
	}

	private int calculateInnerPoints() {
		if (scanPathModel instanceof TwoAxisGridPointsModel) {
			var pointsModel = (TwoAxisGridPointsModel) scanPathModel;
			return pointsModel.getxAxisPoints() * pointsModel.getyAxisPoints();
		} else if (scanPathModel instanceof TwoAxisGridStepModel){
			var stepModel = (TwoAxisGridStepModel) scanPathModel;
			var boundingBox = stepModel.getBoundingBox();
			var xPoints = boundingBox.getxAxisLength()/stepModel.getxAxisStep() + 1;
			var yPoints = boundingBox.getyAxisLength()/stepModel.getyAxisStep() + 1;
			return (int) (xPoints * yPoints + 1);
		} else if (scanPathModel instanceof TwoAxisLinePointsModel){
			return ((TwoAxisLinePointsModel) scanPathModel).getPoints();
		} else {
			var stepModel = (TwoAxisLineStepModel) scanPathModel;
			var points =  stepModel.getBoundingLine().getLength()/stepModel.getStep() + 1;
			return (int) (points + 1);
		}
	}

    private int calculateAllOuterPoints() {
    	return outerScannables.stream()
    			.map(this::calculateOuterPoints)
    			.reduce(1, (product, next) -> product * next);
    }

    private int calculateOuterPoints(IScanPathModel outerPath) {
		try {
			IPointGenerator<?> generator = pointGeneratorService.createGenerator(outerPath);
			return generator.size();
		} catch (GeneratorException e) {
			logger.error("Could not get size of outer path '{}'", outerPath.getName(), e);
			return 1;
		}
    }

	private boolean isPathValid() {
		return (scanPathModel instanceof TwoAxisGridPointsModel
				|| scanPathModel instanceof TwoAxisGridStepModel
				|| scanPathModel instanceof TwoAxisLinePointsModel
				|| scanPathModel instanceof TwoAxisLineStepModel);
	}

	private boolean isRegionValid() {
		return (scanRegionShape instanceof CentredRectangleMappingRegion
				|| scanRegionShape instanceof RectangularMappingRegion
				|| scanRegionShape instanceof LineMappingRegion);
	}

	public IMappingScanRegionShape getScanRegionShape() {
		return scanRegionShape;
	}

	public void setEventId(UUID eventId) {
		this.eventId = eventId;
	}

	public UUID getEventId() {
		return eventId;
	}

}
