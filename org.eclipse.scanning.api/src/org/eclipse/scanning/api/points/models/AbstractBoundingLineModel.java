/*-
 *******************************************************************************
 * Copyright (c) 2011, 2016 Diamond Light Source Ltd.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Matthew Gerring - initial API and implementation and/or initial documentation
 *******************************************************************************/
package org.eclipse.scanning.api.points.models;

import java.math.BigDecimal;

import org.eclipse.scanning.api.ModelValidationException;
import org.eclipse.scanning.api.annotation.UiHidden;
import org.eclipse.scanning.api.annotation.ui.FieldDescriptor;

public abstract class AbstractBoundingLineModel extends AbstractMapModel implements IBoundingLineModel {

	@FieldDescriptor(editable = false) // We edit this with a popup.
	private BoundingLine boundingLine;

	@Override
	@UiHidden
	public BoundingLine getBoundingLine() {
		return boundingLine;
	}

	@Override
	public void setBoundingLine(BoundingLine boundingLine) {
		BoundingLine oldValue = this.boundingLine;
		this.boundingLine = boundingLine;
		this.pcs.firePropertyChange("boundingLine", oldValue, boundingLine);
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = super.hashCode();
		result = prime * result + ((boundingLine == null) ? 0 : boundingLine.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (!super.equals(obj))
			return false;
		AbstractBoundingLineModel other = (AbstractBoundingLineModel) obj;
		if (boundingLine == null) {
			return (other.boundingLine == null);
		}
		return boundingLine.equals(other.boundingLine);
	}

	@Override
	public String toString() {
		return "boundingLine=" + boundingLine + ", "
				+ super.toString();
	}

	/**
	 * Turns a StepModel into an equivalent PointsModel. Some scans (e.g XANES) perform similar scans but with small offsets,
	 * which can catch on floating point calculation errors, giving off-by-one in dataset shapes when reconstructing.
	 * This utility method prevents this situation by converting to a PointsModel, which will always have the same shape,
	 * and performing the divison to find the number of points using BigDecimal.
	 * The BoundingLine of the returned model may differ from that of the input method, due to StepModels being
	 * able to leave a portion of a step towards their end too small for another step. PointsModel however use the entire region,
	 * so this partial line is equivalent in terms of point placement.
	 *
	 * @param model - a TwoAxisLineStepModel
	 * @return pointsModel - a TwoAxisLinePointsModel that will output IPositions that
	 * 						very closely match the IPositions generated by the input
	 */
	public static TwoAxisLinePointsModel enforceShape(TwoAxisLineStepModel model) {
		final TwoAxisLinePointsModel pointsModel = new TwoAxisLinePointsModel();
		if (!model.getName().equals("Step")) {
			pointsModel.setName(model.getName());
		}
		pointsModel.setAlternating(model.isAlternating());
		pointsModel.setContinuous(model.isContinuous());
		pointsModel.setxAxisName(model.getxAxisName());
		pointsModel.setyAxisName(model.getyAxisName());
		pointsModel.setxAxisUnits(model.getxAxisUnits());
		pointsModel.setyAxisUnits(model.getyAxisUnits());

		final BoundingLine copy = new BoundingLine();
		final BoundingLine original = model.getBoundingLine();
		if (original != null) {
			copy.setAngle(original.getAngle());
			copy.setLength(original.getLength());
			copy.setxStart(original.getxStart());
			copy.setyStart(original.getyStart());
		}

		final double step = model.getStep();
		if (step < 0) {
			throw new ModelValidationException("Steps must be in the same direction as the bounding line!", model, "step");
		}

		final int points = Math.max(1, BigDecimal.valueOf(copy.getLength()).divideToIntegralValue(BigDecimal.valueOf(step)).intValue());
		pointsModel.setPoints(points);

		// Trim region that would not have been stepped in, unless 1 step in which case retain
		// but place only a single point in the centre of the box, ignoring that the step was > half length
		if (points > 1) {
			copy.setLength(step * points);
		}
		pointsModel.setBoundingLine(copy);

		return pointsModel;
	}

}
